Here's a structured **Markdown** document comparing the three approaches used to solve **BOJ 17472: 다리 만들기 2** using **BFS + Kruskal**, **Prim's Algorithm**, and **Kruskal's Algorithm**.

---

## 🚀 BOJ 17472: 다리 만들기 2 - 알고리즘 비교

### 📝 문제 개요
- 섬들을 최소 비용의 다리로 연결하는 문제.
- 다리는 최소 길이 `2` 이상이어야 함.
- 다리를 통해 모든 섬을 연결하는 최소 비용을 구해야 함.

---

## 🔍 알고리즘 비교

| **방법론**        | **시간 복잡도**                | **메모리 사용량** | **실행 시간** |
|------------------|----------------------------|----------------|--------------|
| BFS + Kruskal (Union-Find) | **O(V + E log E)** | 14,300 KB      | 108 ms       |
| Prim's Algorithm | **O(V²)** (배열 사용) / **O(E log V)** (우선순위 큐 사용) | 14,320 KB      | 108 ms       |
| Kruskal's Algorithm | **O(E log E)** | 14,328 KB      | 104 ms       |

---

## 🏗 1. BFS + Kruskal (Union-Find)
### ✅ 개요
1. **BFS로 섬을 식별** (각 섬에 고유 번호 부여)
2. **BFS로 모든 가능한 다리 찾기** (우선순위 큐에 저장)
3. **Kruskal’s Algorithm으로 최소 신장 트리 (MST) 구성**
4. **Union-Find 자료구조 사용** (사이클 방지)

### ⏳ 시간 복잡도 분석
- **BFS 탐색**: `O(V)` (V는 섬의 크기)
- **다리 탐색**: `O(V²)`
- **Kruskal 알고리즘**:
  - **간선 정렬**: `O(E log E)`
  - **Union-Find 연산**: `O(α(V))` (거의 상수 시간)
- **총 시간 복잡도**: **O(V² + E log E)**

### 📌 장점
- 비교적 구현이 간단하고, Kruskal 알고리즘 덕분에 빠르게 MST를 찾을 수 있음.

### ⚠️ 단점
- 다리를 찾는 과정이 다소 비효율적 (BFS를 네 방향으로 수행하여 중복 계산 가능성 존재).

---

## 🔥 2. Prim's Algorithm (우선순위 큐 활용)
### ✅ 개요
1. **BFS로 섬을 식별** (각 섬에 고유 번호 부여)
2. **모든 섬 간 다리 정보 저장** (`bridges[][]` 배열 활용)
3. **Prim's Algorithm을 활용해 MST 구성**
   - 한 섬에서 시작해, 가장 짧은 다리를 계속 추가.
   - 우선순위 큐 (`PriorityQueue<Vertex>`) 활용하여 빠르게 최소 비용 다리 선택.

### ⏳ 시간 복잡도 분석
- **BFS 탐색**: `O(V²)`
- **다리 길이 찾기**: `O(V²)`
- **Prim’s Algorithm (우선순위 큐 사용)**:
  - `O(E log V)` (E는 간선 수, V는 노드 수)
- **총 시간 복잡도**: **O(V² + E log V)** (우선순위 큐 활용 시)

### 📌 장점
- **MST를 찾는 과정이 Kruskal보다 직관적** (한 번에 MST를 구성).
- 다리를 저장하는 `bridges[][]` 배열을 활용해 **탐색 속도가 빠름**.

### ⚠️ 단점
- MST 구성 자체는 Kruskal과 유사하지만, **다리를 찾는 과정이 O(V²)로 상대적으로 비효율적**.

---

## ⚡️ 3. Kruskal’s Algorithm (순수 Kruskal 사용)
### ✅ 개요
1. **BFS로 섬을 식별** (각 섬에 고유 번호 부여)
2. **BFS를 사용하여 가능한 모든 다리 탐색 및 저장** (`bridges[][]`)
3. **다리를 `List<Bridge>`에 저장 후 정렬** (우선순위 큐 사용 X)
4. **Kruskal 알고리즘 적용**:
   - 가장 짧은 다리부터 선택하여 Union-Find로 MST 구성

### ⏳ 시간 복잡도 분석
- **BFS 탐색**: `O(V²)`
- **다리 찾기**: `O(V²)`
- **Kruskal 알고리즘**:
  - 간선 정렬: `O(E log E)`
  - Union-Find 연산: `O(α(V))` (거의 상수 시간)
- **총 시간 복잡도**: **O(V² + E log E)**

### 📌 장점
- **Kruskal의 특성상 다리를 정렬 후 MST를 만들므로, 탐색 과정이 효율적**.
- **Union-Find 자료구조 활용하여 매우 빠르게 MST 구성**.

### ⚠️ 단점
- **정렬 과정이 추가적으로 필요함** (`O(E log E)`).
- **다리 찾는 과정은 여전히 BFS를 사용해야 하므로 O(V²) 시간이 걸림**.

---

## 🎯 결론: 어떤 알고리즘이 가장 효율적인가?
### 🚀 **가장 빠른 알고리즘**
- **Kruskal’s Algorithm (순수 Kruskal)**이 **가장 빠름** (104ms)
  - 이유: `O(E log E)`의 효율적인 정렬과 Union-Find의 빠른 병합 연산 덕분.
  - 단, 다리 탐색 과정이 여전히 `O(V²)`이므로 Prim과 큰 차이는 없음.

### 💡 **가장 직관적인 알고리즘**
- **Prim's Algorithm**이 **직관적이며 간단**.
  - 이유: MST를 점진적으로 확장하는 과정이 직관적.
  - 하지만 우선순위 큐를 사용하지 않으면 `O(V²)`로 비효율적.

### 🔨 **BFS + Kruskal (Union-Find)**
- **BFS로 다리 생성 + Kruskal 적용 방식**은 일반적으로 좋은 선택.
- 하지만, **불필요한 다리 탐색 과정**이 많아 Kruskal 단독보다 성능이 약간 떨어짐.

---

## ✅ 최종 선택 가이드
| 사용 상황 | 추천 알고리즘 |
|----------|------------|
| **시간이 중요한 경우** | **Kruskal's Algorithm** |
| **구현이 간단한 방식이 필요할 때** | **Prim's Algorithm** |
| **Union-Find에 익숙하고, 정렬이 문제되지 않을 때** | **BFS + Kruskal** |

### 🚀 결론:
**Kruskal’s Algorithm이 가장 효율적**이지만, 문제에 따라 **Prim's Algorithm도 충분히 좋은 선택**