## **🚀 Solution1 (`Stack<Integer>` 사용, `before`로 중복 제거)**
- **메모리: `69580 KB`**  
- **시간: `1272 ms`**  
- **핵심 개념**:
  - **DFS를 이용한 순열 생성**
  - **`Stack<Integer>`를 이용하여 순열을 저장**
  - **`before` 변수를 사용하여 중복 제거**
  - **중복된 순열을 탐색할 가능성이 있음**

### **🚀 Solution2 (`Set<String>` 사용, 중복 직접 제거)**
- **메모리: `45404 KB`**  
- **시간: `572 ms`**  
- **핵심 개념**:
  - **DFS를 이용하여 `part[]` 배열로 순열 저장**
  - **`Set<String>`을 활용하여 중복 제거**
  - **한 번 생성된 순열을 `Set`을 통해 바로 중복 필터링**

---

# **💡 왜 Solution2가 메모리 사용량과 실행 시간이 더 적을까?**

## **✅ 1. 메모리 사용량 차이 (`Stack<Integer>` vs `Set<String>`)**
- **Solution1 (더 많은 메모리 사용)**
  - `Stack<Integer>`를 사용하여 매번 `add()`와 `pop()`을 수행.
  - `Integer` 객체가 **래퍼 클래스**이므로 박싱/언박싱이 발생 → **메모리 사용 증가**.
  - `before` 변수를 통한 중복 제거 방식은 효율적이지만 **완전한 중복 방지가 어렵다**.

- **Solution2 (더 적은 메모리 사용)**
  - `Set<String>`을 사용하여 **중복을 필터링**하므로 탐색 공간이 줄어든다.
  - `part[]` 배열을 이용하여 순열을 저장하는 방식이므로 **`Stack`보다 가볍다**.
  - 문자열(`String`)을 사용하지만, `LinkedHashSet`을 사용하여 **메모리를 절약**함.

---

## **✅ 2. 실행 시간 차이 (`before` 변수의 한계)**
- **Solution1 (더 느림, `O(N!)` 모든 경우 탐색)**
  - `before` 변수를 활용한 중복 제거가 **완전하지 않아** 중복 탐색 가능성이 있음.
  - 매번 `Stack<Integer>`에서 `get(j)`을 호출하여 순열을 출력하므로 성능 저하.
  - **시간 복잡도: `O(N!)` (모든 경우 탐색 가능성 있음)**.

- **Solution2 (더 빠름, `Set`을 이용한 중복 제거)**
  - `Set<String>`을 활용해 **이미 나온 순열을 즉시 제거** → **중복 탐색이 발생하지 않음**.
  - 탐색 공간이 줄어들어 DFS 수행 횟수가 감소.
  - **시간 복잡도: `O(N! / k)` (중복이 많을수록 성능 향상)**.

---

## **📌 결론**
- **메모리 측면**:
  - `Stack<Integer>`(Solution1)는 **래퍼 클래스로 인해 메모리 사용량이 더 큼**.
  - `Set<String>`(Solution2)는 **고유한 순열만 저장하므로 메모리 사용이 줄어듦**.

- **속도 측면**:
  - `before` 변수를 사용하는 Solution1은 **중복을 완벽하게 제거하지 못해 불필요한 탐색이 더 많음**.
  - `Set<String>`을 활용하는 Solution2는 **중복된 순열을 즉시 제거하여 탐색 공간이 줄어듦**.

**👉 결론적으로 Solution2가 `메모리 절약` & `속도 향상` 모두에서 더 효율적인 방법! 🚀**