# [문제 정리] 백준 16236 - 아기 상어 (BFS + 정렬 방식)

---

## ✅ 문제 개요

- N×N 크기의 격자에서 아기 상어가 먹이를 찾아다니는 시뮬레이션
- 상어는 크기가 작을수록 먹을 수 있는 물고기의 수가 많아짐
- **가장 가까운 먹이를 찾아 먹고, 이동한 거리 총합을 구하는 문제**

---

## 🎯 목표

- 아기 상어가 더 이상 먹을 수 있는 물고기가 없을 때까지 이동하며 먹이를 먹는다
- 상어가 **움직인 거리의 총합**을 출력한다

---

## ✅ 사용 알고리즘

| 알고리즘 | 설명 |
| --- | --- |
| **BFS (너비 우선 탐색)** | 먹을 수 있는 물고기 탐색 시 최단 거리 확보용 |
| **우선순위 정렬** | 먹을 수 있는 물고기가 여러 마리일 때 위→왼쪽 순서로 선택 |

---

## ✅ 핵심 변수 설명

| 변수 | 역할 |
| --- | --- |
| `board[][]` | 전체 맵 저장 (0: 빈 칸, 1~6: 물고기, 9: 아기상어 시작점) |
| `shark[2]` | 상어 위치 (row, col) 저장 |
| `size` | 현재 상어 크기 |
| `eatCount` | 상어가 지금까지 먹은 물고기 수 |
| `ans` | 상어가 움직인 총 거리 (정답) |
| `fish` | 먹을 수 있는 물고기 리스트 (거리 포함) |
| `visited` | BFS 방문 여부 체크 배열 |

---

## ✅ BFS + 정렬 구조 흐름

1. `BFS()` 함수로 현재 상어 위치에서 BFS 시작
2. **먹을 수 있는 물고기를 발견하면** `fish` 리스트에 저장
    - `int[] { row, col, 거리 }` 형태
3. `fish` 리스트가 비어 있지 않으면:
    - **row → col 순서로 정렬**
    - 가장 위, 가장 왼쪽 물고기를 선택하여 이동
    - `ans += 거리`, `eatCount++`
    - `eatCount == size` → 상어 크기 증가
4. 먹은 위치로 이동하여 BFS 재귀적으로 호출
5. `fish` 리스트가 비면 탐색 종료

---

## ⚠️ 주의할 점

| 주의사항 | 설명 |
| --- | --- |
| BFS 도중 가장 가까운 먹이가 `min`보다 멀면 종료 (`break to`) | 탐색 속도 개선용 |
| `fish` 정렬 기준은 `(row, col)` 순 | 문제 조건에서 위쪽, 왼쪽 우선순위 보장 |
| BFS 재귀 호출이므로 `visited`와 `fish`는 매번 초기화해야 함 | 안 하면 이전 탐색 정보가 남음 |
| 이동 가능 조건: `board[nr][nc] <= size` | 자신보다 큰 물고기는 못 지나감 |
| 먹을 수 있는 조건: `0 < board[nr][nc] < size` | 같으면 지나가지만 못 먹음 |

---

## ⏱️ 시간 복잡도 분석

### BFS 한 번 수행:

- 큐 탐색: `O(N^2)`

### 먹을 수 있는 물고기 리스트 정렬:

- 최악의 경우 `O(N^2 log N^2) = O(N^2 log N)`

### 재귀 호출 횟수:

- 최대 N^2번 → 물고기를 한 마리씩 먹는 경우

### **최종 시간 복잡도**:

> O(N^2 × (N^2 log N)) ≒ O(N^4 log N)
> 
> 
> 하지만 N ≤ 20 이므로 충분히 통과 가능
> 

---

## 💡 이 코드만의 특징

| 특징 | 설명 |
| --- | --- |
| `List<int[]> fish` 사용 | 먹을 수 있는 후보를 BFS 탐색 중에 누적 저장 |
| `break to` 라벨문 | **가장 가까운 거리보다 먼 먹이는 무시**하여 성능 향상 |
| BFS 후 재귀 호출 | `while (true)` 없이 BFS 종료 → 다음 위치에서 재호출로 처리 |


## Comparator와 compare() 핵심 요약 (아기 상어 문제 기준)

---

### ✅ 개념 요약

| 항목 | 설명 |
| --- | --- |
| `Comparator` | **사용자 정의 정렬 기준**을 만들기 위한 인터페이스 |
| `compare(T o1, T o2)` | 두 객체를 비교하여 정렬 순서를 결정하는 메서드 |
| 반환값 의미 | `음수`: o1이 o2보다 앞 / `0`: 같음 / `양수`: o1이 o2보다 뒤 |

---

### 🧩 아기 상어 문제에서 왜 필요한가?

- BFS로 먹을 수 있는 물고기를 `List<int[]> fish`에 모두 저장
- 먹을 수 있는 물고기가 **여러 마리**인 경우
    
    → 가장 **위쪽 (row 작은 순)** → 같으면 **왼쪽 (col 작은 순)**
    

➡ Java의 기본 정렬로는 이런 우선순위 구현이 불가능

➡ 그래서 직접 비교 기준을 만드는 `Comparator`가 필요함

---

### 🔍 코드 예시 다시 보기

```java
java
복사편집
Collections.sort(fish, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        if (o1[0] == o2[0]) {
            return o1[1] - o2[1]; // y 좌표(열) 오름차순
        }
        return o1[0] - o2[0];     // x 좌표(행) 오름차순
    }
});

```

---

### 📌 해석

| 코드 | 의미 |
| --- | --- |
| `if (o1[0] == o2[0])` | 두 물고기의 행(x)이 같다면 |
| `return o1[1] - o2[1]` | 열(y) 기준으로 오름차순 정렬 (왼쪽이 먼저) |
| `return o1[0] - o2[0]` | 행(x) 기준으로 오름차순 정렬 (위쪽이 먼저) |

추가 팁: 람다 표현식으로도 가능 (Java 8+)
java
복사
편집
fish.sort((o1, o2) -> {
    if (o1[0] == o2[0]) return o1[1] - o2[1];
    return o1[0] - o2[0];
});