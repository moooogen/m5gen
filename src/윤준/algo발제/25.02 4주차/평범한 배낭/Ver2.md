##  평범한 배낭 ver2

````
import java.util.Scanner;

  

public  class BOJ_12865_Bag_Me {

  

public  static  void main(String[] args) {

Scanner sc = new Scanner(System.in);

int  N = sc.nextInt();

int  K = sc.nextInt();

int[] dp = new  int[K + 1];

for (int  i= 0; i < N; i++) {

int  W = sc.nextInt();

int  V = sc.nextInt();

for(int  j = K; j >= W; j--) {

dp[j] = Math.max(dp[j], dp[j - W] + V);

}

}

System.out.println(dp[K]);

}

  

}
````

----------

` 모든 배열은 선언과 동시에 0의 값을 가지고 있음!!`

## **1️⃣ 코드 설계 방식**


### **✅ DP 테이블 정의**

-   `dp[w]`: **배낭의 현재 무게 `w`일 때, 얻을 수 있는 최대 가치**
-   `dp[K]`는 **배낭의 최대 무게 `K`일 때, 얻을 수 있는 최대 가치**를 의미함.

----------

## **2️⃣ 점화식 (Recurrence Relation)**

````

`for(int j = K; j >= W; j--) {
    dp[j] = Math.max(dp[j], dp[j - W] + V);
}` 
````

-   `dp[j]`: 현재 배낭 무게 `j`에서 얻을 수 있는 최대 가치
-   **현재 물건을 포함하지 않는 경우**  
    → `dp[j] = dp[j]`
-   **현재 물건을 포함하는 경우**  
    → `dp[j] = dp[j - W] + V` (현재 물건의 무게 `W`를 뺀 상태에서 최댓값을 더함)

> **배낭 무게를 `K`에서 `W`까지 감소하는 방향으로 갱신하는 것이 핵심!**
> 
> -   **뒤에서부터 갱신**해야 **이전 값(`dp[j - W]`)이 덮어쓰여 영향을 주지 않음**.
> -   **앞에서부터 진행하면 중복 계산이 발생하여 잘못된 결과가 나올 수 있음**.

----------

## **3️⃣ 알고리즘 수행 과정**

1.  **초기화**
    
    -   `dp[0] = 0` (아무것도 넣지 않았을 때)
    -   나머지 `dp[w]`도 초기값 `0`
2.  **각 물건을 하나씩 고려하며 DP 갱신**
    
    -   물건의 **무게 `W`가 `w`보다 작거나 같을 때만 고려**
    -   **배낭 무게 `K`부터 `W`까지 감소하면서 갱신** (중복 반영 방지)
3.  **최종 결과**
    
    -   `dp[K]`에는 **배낭의 최대 무게 `K`에서 얻을 수 있는 최대 가치**가 저장됨.

----------

## **4️⃣ 시간 복잡도 분석**

시간 복잡도 **O(N × K)**

### **이유 분석**

````

`for (int i= 0; i < N; i++) {  // O(N) 반복문 (각 물건에 대해)
    for(int j = K; j >= W; j--) {  // O(K) 반복문 (배낭 무게 갱신)
        dp[j] = Math.max(dp[j], dp[j - W] + V);
    }
}` 
````

-   **외부 반복문 (`O(N)`)**: `N`개의 물건을 하나씩 처리
-   **내부 반복문 (`O(K)`)**: `K`에서 `W`까지 역순으로 업데이트

### **최악의 경우**

-   `N = 100`
-   `K = 100,000`
-   총 연산 횟수: **`100 × 100,000 = 10,000,000` (천만 번 연산)**

## 🔹 정리

| **설계 요소** | **설명** |
|--------------|-----------------------------------------------|
| **DP 테이블 정의** | `dp[w] = 배낭 무게 w에서 얻을 수 있는 최대 가치` |
| **점화식** | `dp[w] = max(dp[w], dp[w - W] + V)` |
| **시간 복잡도** | `O(N × K)` |
| **공간 복잡도** | `O(K)` (1차원 배열 사용) |
| **최적화 여부** | ✅ 2차원 DP(`O(N × K)`) → 1차원 DP(`O(K)`)로 공간 최적화 |
