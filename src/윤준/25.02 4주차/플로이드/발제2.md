## **1. 주요 연산 분석**

1. **그래프 초기화**
    - `graph = new int[n + 1][n + 1]` → **O(N²)**
    - `Arrays.fill(graph[i], INF)` → **O(N²)**
    - 따라서 그래프 초기화의 시간복잡도는 **O(N²)**
2. **간선 입력 및 저장 (`M`개의 간선)**
    - `for (int i = 0; i < m; i++)`
    - 각 입력마다 `graph[a][b] = Math.min(graph[a][b], c);` 수행
    - **O(M)**
3. **모든 노드에 대해 다익스트라 실행 (`dijkstra(i)`)**
    - `for (int i = 1; i <= n; i++) { result[i] = dijkstra(i); }`
    - 즉, **N번 다익스트라 알고리즘을 수행**

---

## **2. 다익스트라 (`dijkstra(int start)`)의 시간복잡도**

다익스트라는 **우선순위 큐(Priority Queue)를 이용한 방식**으로 구현되어 있음.

1. **우선순위 큐 (`PriorityQueue`)를 이용한 다익스트라의 시간복잡도**
    - **우선순위 큐를 이용하는 경우 시간복잡도:**O((V+E)logV)
    (V: 노드 개수, E: 간선 개수)
        
        O((V+E)log⁡V)O((V + E) \log V)
        
    - 여기서:
        - `V = N` (노드 수)
        - `E = M` (간선 수)
2. **다익스트라 알고리즘 동작 과정**
    - 초기화 (`O(N)`)
    - 우선순위 큐 사용하여 최단 경로 계산:
        - **O((N + M) log N)**
    - 최악의 경우, **모든 노드에서 다익스트라 실행 (N번 반복)**→ **총 시간복잡도**O(N(N+M)logN)
        
        O(N(N+M)log⁡N)O(N (N + M) \log N)
        

---

## **3. 총 시간복잡도**

- 그래프 초기화: **O(N²)**
- 간선 입력: **O(M)**
- **N번 다익스트라 실행:**O(N(N+M)logN)
    
    O(N(N+M)log⁡N)O(N (N + M) \log N)
    
- 전체 시간복잡도:
O(N2+M+N(N+M)logN)
    
    O(N2+M+N(N+M)log⁡N)O(N² + M + N (N + M) \log N)
    
- **주요 지배항**은 `O(N (N + M) log N)`, 따라서 **최종 시간복잡도**는
O(N(N+M)logN)
    
    O(N(N+M)log⁡N)O(N (N + M) \log N)
    

---

## **4. 코드 최적화 및 개선 방향**

- 현재는 **각 노드에서 다익스트라를 실행하여 모든 최단 경로를 구하는 방식**인데,**플로이드-워셜 알고리즘 (Floyd-Warshall, O(N³))** 을 사용하면 **N이 작은 경우 더 효율적일 수도 있음.**
- 만약 **M ≈ N²** (즉, 그래프가 밀집 그래프인 경우),→ **플로이드-워셜 (O(N³))** 이 **다익스트라 (O(N² log N))** 보다 빠를 수도 있음.

✅ **정리하면:**

- **M이 크면 (`M ≫ N`)** → 현재 코드가 적절함 (**O(NM log N)**)
- **M이 작거나 `N²` 수준이면** → 플로이드-워셜 사용 가능 (**O(N³)**)